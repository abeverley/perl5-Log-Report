package Dancer2::Plugin::LogReport;

use warnings;
use strict;

use Dancer2::Plugin;
use Log::Report  'log-report', syntax => 'REPORT';

use Scalar::Util qw/blessed/;

my $_dsl;        # XXX How to avoid the global?   Dancer2::Core::DSL
my $_settings;

=chapter NAME

Dancer2::Plugin::LogReport - logging and exceptions via Log::Report

=chapter SYNOPSIS

  # Load the plugin into Dancer2
  # see Log::Report::import() for %options
  use Dancer2::Plugin::LogReport %options;

  # Stop execution, redirect, and display an error to the user
  $name or error "Please enter a name";

  # Add debug information to logger
  trace "We're here";

  # Handling user errors cleanly
  if (process( sub {MyApp::Model->create_user} )) {
      # Success, redirect user elsewhere
  } else {
      # Failed, continue as if submit hadn't been made.
      # Error message will be in session for display later.
  }

  # Send errors to template for display
  hook before_template => sub {
      my $tokens = shift;
      $tokens->{messages} = session 'messages';
      session 'messages' => [];
  }

=chapter DESCRIPTION

This module provides easy access to the extensive logging facilities
provided by M<Log::Report>. Along with M<Dancer2::Logger::LogReport>,
this brings together all the internal Dancer2 logging, handling for
expected and unexpected exceptions, translations and application logging.

Logging is extremely flexible using many of the available
L<dispatchers|Log::Report::Dispatcher/DETAILS>.  Multiple dispatchers can be
used, each configured separately to display different messages in different
formats.  By default, messages are logged to a session variable for display on
a webpage, and to STDERR.

Read the L</DETAILS> in below in this manual-page.

=chapter METHODS

=cut

# "use" import
sub import
{   my $class = shift;
    Log::Report->import('+2', @_, syntax => 'LONG');
}

# Dancer2 import
on_plugin_import
{   my $dsl      = $_dsl      = shift;  # capture global singleton
    my $settings = $_settings = plugin_setting;

    # Need init_error for exceptions and other errors
    $dsl->hook(init_error => sub {
        my $error = shift;
        # Catch other exceptions. This hook is called for all errors
        # not just exceptions (including for example 404s), so check first.
        # If it's an exception then panic it to get Log::Report
        # to handle it nicely. If it's another error such as a 404
        # then exception will not be set.
        report 'PANIC' => $error->{exception}
            if $error->{exception};
    });

    if($settings->{handle_http_errors})
    {   # Need after_error for HTTP errors (eg 404) so as to
        # be able to change the forwarding location
        $dsl->hook(after_error => sub {
            use Data::Dumper; say STDERR Dumper \@_;
            my $error = shift;
            my $msg = $error->status . ": "
              . Dancer2::Core::HTTP->status_message($error->status);

            # XXX How to write messages to the session? request() is not
            # in the DSL at this point. At least log it.
            report 'TRACE' => $msg;
            _forward_home( $error, danger => $msg ); # $error is the request
        });
    }

    # This is so that all messages go into the session, to be displayed
    # on the web page (if required)
    dispatcher CALLBACK => 'error_handler'
      , callback => \&_error_handler
      , mode     => 'DEBUG';
};    # ";" required!

=method process

C<process()> is an eval, but one which expects and handles exceptions
generated by M<Log::Report>. Any messages will be logged as normal in
accordance with the dispatchers, but any fatal exceptions will be caught
and handled gracefully.  This allows much simpler error handling, rather
than needing to test for lots of different scenarios.

In a module, it is enough to simply use the C<error> keyword in the event of a
fatal error.

The return value will be 1 for success or 0 if a fatal exception occurred.

See the L</DETAILS> for an example of how this is expected to be used.

Modules do not need to use this plugin, instead they can C<use Log::Report>.

=cut

sub process($$)
{   my ($dsl, $coderef) = @_;
    try { $coderef->() };

    # Return true on success
    if (my $exception = $@->wasFatal)
    {   $exception->throw(is_fatal => 0);
        return 0;
    }
    $@->reportAll;
    1;
}

register process => \&process;

sub _message_add($$)
{   my ($type, $text) = @_;
    $text && $type or return;
    unless ($_dsl->app->request)
    {   # This happens for HTTP errors
        # XXX the session is not available in the DSL
        report 'ASSERT' => "Unable to write message to session: unable to write cookie";
        return;
    }
    my $messages_variable = $_settings->{messages_key} || 'messages';
    my $session           = $_dsl->app->session;
    my $msgs              = $session->read($messages_variable);
    push @$msgs, { text => $text, type => $type };
    $session->write($messages_variable => $msgs);
}

#------
=section Handlers

All the standard M<Log::Report> functions are available to use. Please see the
L<Log::Report/"The Reason for the report"> for details
of when each one should be used.

=method trace
=method assert
=method info
=method notice
=method warning
=method mistake
=method error
=method fault
=method alert
=method failure
=method panic
=cut

sub _forward_home($$$)
{   my $dsl = shift;
    _message_add(shift, shift);
    my $page = $_settings->{forward_url} || '/';
    $dsl->redirect($page);
}

sub _error_handler($$$$)
{   my ($disp, $options, $reason, $message) = @_;

    my $fatal_handler = sub {
        _forward_home( $_dsl, danger => $_[0] )
            unless $_dsl->request->uri eq '/' && $_dsl->request->is_get;
    };

    my %handler =
      ( # Default do nothing for the moment (TRACE|ASSERT|INFO)
        default => sub {}

        # Notice that something has happened. Not an error.
      , NOTICE  => sub {_message_add info => $_[0]}

        # Non-fatal problem. Show warning.
      , WARNING => sub {_message_add warning => $_[0]}

        # Non-fatal problem. Show warning.
      , MISTAKE => sub {_message_add warning => $_[0]}

        # A user-created error condition that is not recoverable.
        # This could have already been caught by the process
        # subroutine, in which case we should continue running
        # of the program. In all other cases, we should bail
        # out. With the former, the exception will have been
        # re-thrown as a non-fatal exception, so check that.
      , ERROR   => sub {
            return _message_add( danger => $_[0] )
                if exists $options->{is_fatal} && !$options->{is_fatal};

            return  _forward_home( $_dsl, danger => $_[0] )
                if $_dsl->request->uri ne '/' || !$_dsl->request->is_get;

            return;
       }

        # 'FAULT', 'ALERT', 'FAILURE', 'PANIC'
        # All these are fatal errors. Display error to user, but
        # forward home so that we can reload. However, don't if
        # it's a GET request to the home, as it will cause a recursive
        # loop. In this case, do nothing, and let dancer handle it.
      , FAULT   => $fatal_handler
      , ALERT   => $fatal_handler
      , FAILURE => $fatal_handler
      , PANIC   => $fatal_handler
      );

    my $call = $handler{$reason} || $handler{default};
    $call->("$message");
}

sub _report($@) {
    my ($reason, $dsl) = (shift, shift);

    my $msg = (blessed($_[0]) && $_[0]->isa('Log::Report::Message'))
       ? $_[0] : Dancer2::Core::Role::Logger::_serialize(@_);

    report uc($reason) => $msg;
}

register trace   => sub { _report(TRACE => @_) };
register assert  => sub { _report(ASSERT => @_) };
register notice  => sub { _report(NOTICE => @_) };
register mistake => sub { _report(MISTAKE => @_) };
register panic   => sub { _report(PANIC => @_) };
register alert   => sub { _report(ALERT => @_) };

register_plugin for_versions => ['2'];

#----------
=chapter DETAILS

This chapter will guide you through the myriad of ways that you can use
M<Log::Report> in your Dancer2 application.

We will set up our application to do the following:

=over 4

=item Messages to the user
We'll look at an easy way to output messages to the user's web page, whether
they be informational messages, warnings or errors.

=item Debug information
We'll look at an easy way to log debug information, at different levels.

=item Manage unexpected exceptions
We'll handle unexpected exceptions cleanly, in the unfortunate event that
they happen in your production application.

=item Email alerts of significant errors
If we do get unexpected errors then we want to be notified them.

=item Log DBIC information and errors
We'll specifically look at nice ways to log SQL queries and errors when
using DBIx::Class.

=back

=section Larger example

In its simplest form, this module can be used for more flexible logging

  get '/route' => sub {
      # Stop execution, redirect, and display an error to the user
      $name or error "Please enter a name";
 
      # The same but translated
      $name or error __"Please enter a name";
  
      # The same but translated and with variables
      $name or error __x"{name} is not valid", name => $name;
 
      # Show the user a warning, but continue execution
      mistake "Not sure that's what you wanted";
 
      # Add debug information, can be caught in syslog by adding
      # the (for instance) syslog dispatcher
      trace "Hello world";
   };

=section Setup and Configuration

To make full use of L<Log::Report>, you'll need to use both
L<Dancer2::Logger::LogReport> and L<Dancer2::Plugin::LogReport>.

=subsection Dancer2::Logger::LogReport

Set up L<Dancer2::Logger::LogReport> by adding it to your Dancer2
application configuration (see L<Dancer2::Config>). By default,
all messages will go to STDERR.

To get all message out "the Perl way" (using print, warn and die) just use

  logger: "LogReport"

At start, these are handled by a M<Log::Report::Dispatcher::Perl> object,
named 'default'.  If you open a new dispatcher with the name 'default',
the output via the perl mechanisms will be stopped.

To also send messages to your syslog:

  logger: "LogReport"

  engines:
    logger:
      LogReport:
        log_format: %a%i%m
        app_name: MyApp
        dispatchers:
          default:              # Name
            type: SYSLOG        # Log::Reporter::dispatcher() options
            identity: gads
            facility: local0
            flags: "pid ndelay nowait"
            mode: DEBUG

To send messages to a file:

  logger: "LogReport"

  engines:
    logger:
      LogReport:
        log_format: %a%i%m
        app_name: MyApp
        dispatchers:
          logfile:              # "default" dispatcher stays open as well
            type: FILE
            to: /var/log/myapp.log
            charset: utf-8
            mode: DEBUG

See L<Log::Report::Dispatcher> for full details of options.

Finally: on Dancer2 script may run many applications.  Each application
has its own logger configuration.  Be aware that some loggers (for instance
syslog) can exist only once in a program.  When you use the specify a
logger name for a second app (without parameters) the logger object will 
be shared.

Example: reuse dispatchers 'default' and 'logfile'

  engines:
    logger:
      LogReport:
        app_name: Other App
        dispatchers:
	  default:   
          logfile:

=subsection Dancer2::Plugin::LogReport

To use the plugin, you simply use it in your application:

  package MyApp;
  use Dancer2;
  use Dancer2::Plugin::LogReport %config;

Dancer2::Plugin::LogReport takes the same C<%config> options as
L<Log::Report>.

If you want to send messages from your modules/models, there is
no need to use this specific plugin. Instead, you should simply
C<use Log::Report> to negate the need of loading all the Dancer2
specific code.

=section In use

=subsection Logging debug information

In its simplest form, you can now use all the
L<Log::Report logging functions|Log::Report#The-Reason-for-the-report>
to send messages to your dispatchers (as configured in the Logger
configuration):

  trace "I'm here";

  warning "Something dodgy happened";

  panic "I'm bailing out";

  # Additional, special Dancer2 keyword
  success "Settings saved successfully";

=subsection Exceptions

Log::Report is a combination of a logger and an exception system.  Messages
to be logged a I<thrown> to all listening dispatchers to be handled.

This module will also catch any unexpected exceptions:

  # This will be caught, the error will be logged (full stacktrace to STDOUT,
  # short message to the session messages), and the user will be forwarded
  # (default to /). This would also be sent to syslog with the appropriate
  # dispatcher.
  get 'route' => sub {
      my $foo = 1;
      my $bar = $foo->{x}; # whoops
  }

=subsection Sending messages to the user

To make it easier to send messages to your users, messages at the following
levels are also stored in the user's session: C<notice>, C<warning>, C<mistake>
and C<error>.

You can pass these to your template and display them at each page render:

  hook before_template => sub {
    my $tokens = shift;
    $tokens->{messages} = session 'messages';
    session 'messages' => []; # Clear the message queue
  }

Then in your template (for example the main layout):

  [% FOR message IN messages %]
    [% IF message.type %]
      [% msgtype = message.type %]
    [% ELSE %]
      [% msgtype = "info" %]
    [% END %]
    <div class="alert alert-[% msgtype %]">
      [% message.text | html_entity %]
    </div>
  [% END %]

The C<type> of the message is compatible with Bootstrap contextual colors:
C<info>, C<warning> or C<danger>.

Now, anywhere in your application that you have used Log::Report, you can

  warning "Hey user, you should now about this";

and the message will be sent to the next page the user sees.

=subsection Handling user errors

Sometimes we write a function in a model, and it would be nice to have a
nice easy way to return from the function with an error message. One
way of doing this is with a separate error message variable, but that
can be messy code. An alternative is to use exceptions, but these
can be a pain to deal with in terms of catching them.
Here's how to do it with Log::Report.

In this example, we do use exceptions, but in a neat, easier to use manner.

First, your module/model:

  package MyApp::CD;

  sub update {
    my ($self, %values) = @_;
    $values{title} or error "Please enter a title";
    $values{description} or warning "No description entered";
  }

Then, in your controller:

  package MyApp;
  use Dancer2;

  post '/cd' => sub {
    my %values = (
      title       => param('title');
      description => param('description');
    );
    if (process sub { MyApp::CD->update(%values) } ) {
      success "CD updated successfully";
      redirect '/cd';
    }

    template 'cd' => { values => \%values };
  }

Now, when update() is called, any exceptions are caught. However, there is
no need to worry about any error messages. Both the error and warning
messages in the above code will have been stored in the messages session
variable, where they can be displayed using the code in the previous section.
The C<error> will have caused the code to stop running, and process()
will have returned false. C<warning> will have simply logged the warning
and not caused the function to stop running.

=subsection Logging DBIC database queries and errors

If you use L<DBIx::Class> in your application, you can easily integrate
its logging and exceptions. To log SQL queries:

  # Log all queries and execution time
  $schema->storage->debugobj(new Log::Report::DBIC::Profiler);
  $schema->storage->debug(1);

By default, exceptions from DBIC are classified at the level "error". This
is normally a user level error, and thus may be filtered as normal program
operation. If you do not expect to receive any DBIC exceptions, then it
is better to class them at the level "panic":

  # panic() DBIC errors
  $schema->exception_action(sub { panic @_ });
  # Optionally get a stracktrace too
  $schema->stacktrace(1);

If you are occasionally running queries where you expect to naturally
get exceptions (such as not inserting multiple values on a unique constraint),
then you can catch these separately:

  try { $self->schema->resultset('Unique')->create() };
  # Log any messages from try block, but only as trace
  $@->reportAll(reason => 'TRACE');

=subsection Email alerts of exceptions

If you have an unexpected exception in your production application,
then you probably want to be notified about it. One way to do so is
configure rsyslog to send emails of messages at the panic level. Use
the following configuration to do so:

  # Normal logging from LOCAL0
  local0.*                        -/var/log/myapp.log

  # Load the mail module
  $ModLoad ommail
  # Configure sender, receiver and mail server
  $ActionMailSMTPServer localhost
  $ActionMailFrom root
  $ActionMailTo root
  # Set up an email template
  $template mailSubject,"Critical error on %hostname%"
  $template mailBody,"RSYSLOG Alert\r\nmsg='%msg%'\r\nseverity='%syslogseverity-text%'"
  $ActionMailSubject mailSubject
  # Send an email no more frequently than every minute
  $ActionExecOnlyOnceEveryInterval 60
  # Configure the level of message to notify via email
  if $syslogfacility-text == 'local0' and $syslogseverity < 3 then :ommail:;mailBody
  $ActionExecOnlyOnceEveryInterval 0

With the above configuration, you will only be emailed of severe errors, but can
view the full log information in /var/log/myapp.log


=cut

1;

