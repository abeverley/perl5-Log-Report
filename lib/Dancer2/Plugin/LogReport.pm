package Dancer2::Plugin::LogReport;

use warnings;
use strict;

use Dancer2::Plugin;
use Log::Report  'log-report', syntax => 'REPORT';

use Scalar::Util qw/blessed/;

my $_dsl;        # XXX How to avoid the global?
my $_settings;

=chapter NAME

Dancer2::Plugin::LogReport - logging and exceptions via Log::Report

=chapter SYNOPSIS

  # Load the plugin into Dancer2
  # see Log::Report::import() for %options
  use Dancer2::Plugin::LogReport %options;

  # Stop execution, redirect, and display an error to the user
  $name or error "Please enter a name";

  # Add debug information to logger
  trace "We're here";

  # Handling user errors cleanly
  if (process( sub {MyApp::Model->create_user} )) {
      # Success, redirect user elsewhere
  } else {
      # Failed, continue as if submit hadn't been made.
      # Error message will be in session for display later.
  }

  # Send errors to template for display
  hook before_template => sub {
      my $tokens = shift;
      $tokens->{messages} = session 'messages';
      session 'messages' => [];
  }

=chapter DESCRIPTION

This module provides easy access to the extensive logging facilities
provided by M<Log::Report>. Along with M<Dancer2::Logger::LogReport>,
this brings together all the internal Dancer2 logging, handling for
expected and unexpected exceptions, translations and application logging.

Logging is extremely flexible using many of the available
L<dispatchers|Log::Report::Dispatcher/DETAILS>.  Multiple dispatchers can be
used, each configured separately to display different messages in different
formats.  By default, messages are logged to a session variable for display on
a webpage, and to STDERR.

=chapter METHODS

=cut

# "use" import
sub import
{   my $class = shift;
    Log::Report->import('+2', @_, syntax => 'LONG');
}

# Dancer2 import
on_plugin_import
{   my $dsl      = $_dsl      = shift;  # capture global singleton
    my $settings = $_settings = plugin_setting;

    # Need init_error for exceptions and other errors
    $dsl->hook(init_error => sub {
        my $error = shift;
        # Catch other exceptions. This hook is called for all errors
        # not just exceptions (including for example 404s), so check first.
        # If it's an exception then panic it to get Log::Report
        # to handle it nicely. If it's another error such as a 404
        # then exception will not be set.
        report 'PANIC' => $error->{exception}
            if $error->{exception};
    });

    if ($settings->{handle_http_errors})
    {   # Need after_error for HTTP errors (eg 404) so as to
        # be able to change the forwarding location
        $dsl->hook(after_error => sub {
            use Data::Dumper; say STDERR Dumper \@_;
            my $error = shift;
            my $msg = $error->status . ": "
              . Dancer2::Core::HTTP->status_message($error->status);

            # XXX How to write messages to the session? request() is not
            # in the DSL at this point. At least log it.
            report 'TRACE' => $msg;
            _forward_home( $error, danger => $msg ); # $error is the request
        });
    }

    # This is so that all messages go into the session, to be displayed
    # on the web page (if required)
    dispatcher CALLBACK => 'error_handler'
      , callback => \&_error_handler
      , mode     => 'DEBUG';
};    # ";" required!

=method process

C<process()> is an eval, but one which expects and handles exceptions
generated by M<Log::Report>. Any messages will be logged as normal in
accordance with the dispatchers, but any fatal exceptions will be caught
and handled gracefully.  This allows much simpler error handling, rather
than needing to test for lots of different scenarios.

In a module, it is enough to simply use the C<error> keyword in the event of a
fatal error.

The return value will be 1 for success or 0 if a fatal exception occurred.

See the L</DETAILS> for an example of how this is expected to be used.

Modules do not need to use this plugin, instead they can C<use Log::Report>.

=cut

sub process($$)
{   my ($dsl, $coderef) = @_;
    try { $coderef->() };

    # Return true on success
    if (my $exception = $@->wasFatal)
    {   $exception->throw(is_fatal => 0);
        return 0;
    }
    $@->reportAll;
    1;
}

register process => \&process;

sub _message_add($$)
{   my ($type, $text) = @_;
    $text && $type or return;
    unless ($_dsl->app->request)
    {   # This happens for HTTP errors
        # XXX the session is not available in the DSL
        report 'ASSERT' => "Unable to write message to session: unable to write cookie";
        return;
    }
    my $messages_variable = $_settings->{messages_key} || 'messages';
    my $session           = $_dsl->app->session;
    my $msgs              = $session->read($messages_variable);
    push @$msgs, { text => $text, type => $type };
    $session->write($messages_variable => $msgs);
}

#------
=section Handlers

All the standard M<Log::Report> functions are available to use. Please see the
L<Log::Report/"The Reason for the report"> for details
of when each one should be used.

=method trace
=method assert
=method info
=method notice
=method warning
=method mistake
=method error
=method fault
=method alert
=method failure
=method panic
=cut

sub _forward_home($$$)
{   my $dsl = shift;
    _message_add(shift, shift);
    my $page = $_settings->{forward_url} || '/';
    $dsl->redirect($page);
}

sub _error_handler($$$$)
{   my ($disp, $options, $reason, $message) = @_;

    my $fatal_handler = sub {
        _forward_home( $_dsl, danger => $_[0] )
            unless $_dsl->request->uri eq '/' && $_dsl->request->is_get;
    };

    my %handler =
      ( # Default do nothing for the moment (TRACE|ASSERT|INFO)
        default => sub {}

        # Notice that something has happened. Not an error.
      , NOTICE  => sub {_message_add info => $_[0]}

        # Non-fatal problem. Show warning.
      , WARNING => sub {_message_add warning => $_[0]}

        # Non-fatal problem. Show warning.
      , MISTAKE => sub {_message_add warning => $_[0]}

        # A user-created error condition that is not recoverable.
        # This could have already been caught by the process
        # subroutine, in which case we should continue running
        # of the program. In all other cases, we should bail
        # out. With the former, the exception will have been
        # re-thrown as a non-fatal exception, so check that.
      , ERROR   => sub {
            exists $options->{is_fatal} && !$options->{is_fatal}
                ? _message_add( danger => $_[0] )
                : _forward_home( $_dsl, danger => $_[0] );
        }

        # 'FAULT', 'ALERT', 'FAILURE', 'PANIC'
        # All these are fatal errors. Display error to user, but
        # forward home so that we can reload. However, don't if
        # it's a GET request to the home, as it will cause a recursive
        # loop. In this case, do nothing, and let dancer handle it.
      , FAULT   => $fatal_handler
      , ALERT   => $fatal_handler
      , FAILURE => $fatal_handler
      , PANIC   => $fatal_handler
      );

    my $call = $handler{$reason} || $handler{default};
    $call->("$message");
}

sub _report($@) {
    my ($reason, $dsl) = (shift, shift);

    my $msg = (blessed($_[0]) && $_[0]->isa('Log::Report::Message'))
       ? $_[0] : Dancer2::Core::Role::Logger::_serialize(@_);

    report uc($reason) => $msg;
}

register trace   => sub { _report(TRACE => @_) };
register assert  => sub { _report(ASSERT => @_) };
register notice  => sub { _report(NOTICE => @_) };
register mistake => sub { _report(MISTAKE => @_) };
register panic   => sub { _report(PANIC => @_) };
register alert   => sub { _report(ALERT => @_) };

register_plugin for_versions => ['2'];

#----------
=chapter DETAILS

=section Larger example

In its simplest form, this module can be used for more flexible logging

  get '/route' => sub {
      # Stop execution, redirect, and display an error to the user
      $name or error "Please enter a name";
 
      # The same but translated
      $name or error __"Please enter a name";
  
      # The same but translated and with variables
      $name or error __x"{name} is not valid", name => $name;
 
      # Show the user a warning, but continue exection
      mistake "Not sure that's what you wanted";
 
      # Add debug information, can be caught in syslog by adding the syslog
      # dispatcher
      trace "Hello world"; };

The module can also be used in models to test for user input and act
accordingly, without needing to set up complicated error handling:

  # In a module
  package MyApp::MyModel sub create_user {
      ...
      $surname or error "Please enter a surname"; # Execution stops here
      ...
      $telephone or mistake "Tel not entered"; # Execution continues
      ...
  }
  
  # In the main app
  get '/user' => sub {
      ...
      if (param 'submit') {
          if (process( sub { MyApp::Model->create_user() })) {
              # Success, redirect user elsewhere
          }
      }
      # Failed, continue as if submit hadn't been made. Error will have been
      # logged in session to be displayed later.
  };

This module will also catch any unexpected exceptions:

  # This will be caught, the error will be logged (full stacktrace to STDOUT,
  # short message to the session messages), and the user will be forwarded
  # (default to /). This would also be sent to syslog with the appropriate
  # dispatcher.
  get 'route' => sub {
      my $foo = 1;
      my $bar = $foo->{x}; # whoops
  }

Errors are all logged to the session. These need to be cleared once they have
been displayed.

  hook before_template => sub {
      my $tokens = shift;
      # Pass messages to template and clear session
      $tokens->{messages} = session 'messages';
      session 'messages' => [];
  }
  
In the template. This example prints them in Bootstrap colors:

 [% FOR message IN messages %]
     [% IF message.type %]
         [% msgtype = message.type %]
     [% ELSE %]
         [% msgtype = "info" %]
     [% END %]
     <div class="alert alert-[% msgtype %]">
         [% message.text | html_entity %]
     </div>
 [% END %]

=section Configuration

=subsection Dancer2 configuration

In your application's configuration file (values shown are defaults):

  plugins: LogReport
          # Set the forward URL on fatal error that isn't caught
          forward_url: /

          # Set to 1 if you want the module to also catch Dancer HTTP errors
          # (such as 404s)
          handle_http_errors: 0

          # Configure session variable for messages
          messages_key = messages

=subsection Log::Report configuration

Any L<Log::Report configuration options|Log::Report/Configuration> can also be
used with this plugin.

=subsection Dancer2::Logger::LogReport

You probably want to also use and configure M<Dancer2::Logger::LogReport>.
See its documentation for full details.

=cut

1;

